# 逐行解析：用树状数组统计逆序对（C++，无结构体写法）

下面给出“朴素函数 + 全局数组”的实现，并在同一份代码里逐行写上注释，配合后文的关键行详解，帮助你彻底吃透它的工作原理与细节。

```cpp name=main.cpp
#include <bits/stdc++.h>                      // 1) 引入常用标准库（竞赛常用头）
using namespace std;                          // 2) 省去 std:: 前缀

static vector<long long> BIT;                 // 3) 全局树状数组（Fenwick），1-based，下标从 1 开始
                                              //    用 long long 存前缀和，避免累加溢出

// 在秩 i 的位置加上 v：BIT[i] += v，并把它影响到的父节点都更新到
inline void add(int i, long long v) {         // 4) 单点增加：O(log M)，M 为离散值个数
    for (int n = (int)BIT.size() - 1;         // 5) n 为 BIT 的最大合法下标（size()-1，因为 1-based）
         i <= n;                              // 6) 只要还在树状数组范围内
         i += i & -i)                         // 7) i += lowbit(i)：向上跳到包含当前点的更大区间（父节点）
        BIT[i] += v;                          // 8) 把该区间（以 i 为右端点，长度 lowbit(i)）的和加上 v
}

// 返回前缀和 sum(1..i)：BIT[1] + ... + BIT[i]
inline long long sum(int i) {                 // 9) 前缀和查询：O(log M)
    long long s = 0;                          // 10) 累加器（64 位，防溢出）
    for (; i > 0;                             // 11) 从 i 往上跳父链，直到 0
         i -= i & -i)                         // 12) i -= lowbit(i)：去掉当前区间长度，跳到更小的祖先区间
        s += BIT[i];                          // 13) 累加当前节点保存的区间和
    return s;                                 // 14) 返回前缀和
}

int main() {                                  // 15) 主程序入口
    ios::sync_with_stdio(false);              // 16) 关同步以加速 C++ 流
    cin.tie(nullptr);                         // 17) 解绑 cin/cout，进一步加速

    int n;                                    // 18) 数组长度
    if (!(cin >> n)) return 0;                // 19) 读失败直接退出（鲁棒）
    vector<long long> a(n);                   // 20) 原数组（值最大可达 1e9，用 long long 也 OK）
    for (int i = 0; i < n; ++i)               // 21) 读取 n 个数
        cin >> a[i];

    // --- 离散化：把大值域映射到紧凑的 1..M，仅保序（大小关系不变） ---
    vector<long long> vals = a;               // 22) 拷贝一份用于构造“值表”
    sort(vals.begin(), vals.end());           // 23) 排序：相同值会相邻
    vals.erase(unique(vals.begin(), vals.end()),
               vals.end());                   // 24) 去重：得到严格递增的“去重值表”
                                              //     rank(x) = lower_bound(vals, x) - vals.begin() + 1

    BIT.assign((int)vals.size() + 1, 0);      // 25) 初始化树状数组，长度 M+1（丢弃 0 号位，1-based）
    long long ans = 0;                        // 26) 逆序对计数（最大 ~ n*(n-1)/2，需 64 位）

    for (int i = 0; i < n; ++i) {             // 27) 从左到右扫描 a[0..n-1]
        int r = int(lower_bound(vals.begin(),
                                 vals.end(),
                                 a[i]) - vals.begin()) + 1; // 28) 当前值 a[i] 的秩 r（1-based）

        long long le = sum(r);                // 29) le = 左侧（已处理 i 个）中 ≤ a[i] 的个数
        ans += i - le;                        // 30) 本位产生的逆序对 = 左侧总数 i - ≤a[i] 个数 le（即 >a[i]）
        add(r, 1);                            // 31) 把当前值计入频次，为后续元素服务
    }

    cout << ans << '\n';                      // 32) 输出逆序对总数
    return 0;                                 // 33) 程序结束
}
```

---

## 关键行与概念详解

### 1) 为什么要离散化（22–24 行）

- 树状数组需要“连续小整数”做下标，而原数据范围到 1e9，无法直接当下标用。
- 排序 + 去重得到严格递增的值表 `vals`，这样：
    - rank(x) = 在 `vals` 中的有序位置 + 1。
    - 只保留大小关系，不改变相对顺序，逆序对的定义完全不受影响。

小结：离散化把值域压成 1..M，使树状数组能工作。

### 2) 树状数组是怎么组织区间的（4–14 行）

- `lowbit(i) = i & -i` 给出以 i 为右端点的区间长度。
    - 例如 i=12（二进制 1100），lowbit(12)=4，意味着 BIT[12] 管的是区间 (9..12)。
- add(i, v)：把涉及 i 的所有“父区间”都加 v；路径是 i, i+lowbit(i), ...
- sum(i)：把覆盖 [1..i] 的若干区间“拼起来”；路径是 i, i-lowbit(i), ...

这两个过程都只走 O(log M) 次跳转，因而效率高。

### 3) 为什么贡献公式是 i - sum(r)（29–31 行）

- 扫描到下标 i（0-based）时，左侧已经处理了 i 个元素。
- `sum(r)` = 左侧“≤ a[i]”的个数，记为 le。
- 左侧“> a[i]”的就是 i - le，这些元素与 a[i] 形成逆序对。
- 注意是“严格大于”，所以必须减去“等于”的数量，这就是为什么要用 `sum(r)`（≤）而不是 `sum(r-1)`（<）。

对比另一种写法：

- 如果从右向左遍历，就该数“右侧严格小于”的个数，公式才是 `sum(r-1)`。

### 4) 1-based 的原因与 BIT 大小（25 行）

- 树状数组要求下标从 1 开始，因为 `lowbit(0)=0` 会导致死循环。
- 因此长度要开到 `M+1`，并且秩计算后要再 `+1` 转成合法下标。

### 5) long long 的必要性（3、10、20、26 行）

- 最大逆序对数约为 n*(n-1)/2。n=2e5 时 ≈ 2e10，超 32 位上限。
- 所以：
    - BIT 里存的计数（前缀和）用 long long。
    - 最终答案 `ans` 也用 long long。
    - `le` 是 long long，表达式 `i - le` 会被提升到 64 位再和 `ans` 相加，安全。

### 6) I/O 加速与鲁棒性（16–21 行）

- 关同步、解绑流，大输入更快。
- `if (!(cin >> n)) return 0;` 让程序在输入异常时安静退出。

### 7) `unique + erase` 的惯用法（23–24 行）

- `sort` 后相同元素相邻。
- `unique` 返回“去重后尾部开始”的迭代器；配合 `erase` 去掉重复段。
- 得到严格递增的 `vals`，lower_bound 可以二分秩。

---

## 运行流程小演示（与代码一致）

以 a = [3, 1, 2, 2] 为例：

- 离散化：vals = [1,2,3]，rank(1)=1，rank(2)=2，rank(3)=3
- i=0, a=3, r=3：le=sum(3)=0，贡献=0-0=0，add(3,1)
- i=1, a=1, r=1：le=sum(1)=0，贡献=1-0=1，add(1,1)
- i=2, a=2, r=2：le=sum(2)=1，贡献=2-1=1，add(2,1)
- i=3, a=2, r=2：le=sum(2)=2，贡献=3-2=1，add(2,1)
- 答案=3，对应 (3,1)、(3,2@i=2)、(3,2@i=3)

---

## 复杂度与空间

- 离散化排序：O(n log n)
- 每次 add/sum：O(log n)，共 n 次
- 总体时间：O(n log n)
- 额外空间：O(n)（数组 + BIT）

---

## 常见坑位提醒

- 从左到右遍历时，贡献必须是 `i - sum(r)`，否则会把“相等的”算进逆序对。
- BIT 要 1-based，`assign(M+1, 0)`；rank 需要 `+1`。
- 离散化必须 `unique` 去重；否则相同值映射到不同秩，会错。
- 答案与 BIT 都用 64 位；否则大数据会溢出。
- 不要对原数组排序后直接用它参与计算；排序只用于构造 `vals` 映射。