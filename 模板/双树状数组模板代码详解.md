# 双树状数组模板代码详解

## 概述：这段代码是用来做什么的？

这段代码实现了一种高级数据结构，旨在高效地解决一类常见的数组问题：**区间更新与区间查询**。

具体来说，它支持对一个数组进行两种操作：

1.  **区间更新 (Range Update)**：将数组中一个指定区间 `[l, r]` 内的所有元素同时增加一个值 `k`。
2.  **区间查询 (Range Query)**：计算数组中一个指定区间 `[l, r]` 内所有元素的和。

若使用普通数组，这两种操作的时间复杂度均为 O(N)，在操作次数很多时效率低下。而本代码利用**两个树状数组（Fenwick Tree）**，将这两种操作的时间复杂度都优化到了 **O(log N)**，极大地提升了算法性能。

---

## 核心思想：差分 + 树状数组

要理解双树状数组的原理，我们需要先掌握两个前置概念：

### 1. 树状数组 (Fenwick Tree / Binary Indexed Tree)

它是一种数据结构，能以 O(log N) 的时间复杂度完成以下两种操作：
*   **单点更新**：`update(idx, val)`，给数组的第 `idx` 个位置增加 `val`。
*   **前缀和查询**：`sum(idx)`，查询数组 `[1, idx]` 区间的总和。

### 2. 差分数组 (Difference Array)

对于一个原数组 `A`，我们可以定义它的差分数组 `D`：
`D[i] = A[i] - A[i-1]` (特别地, `D[1] = A[1]`)

差分数组有一个非常关键的特性：
> 对原数组 `A` 的一个区间 `[l, r]` 里的所有数都加上 `k`，这个操作**等价于**在差分数组 `D` 上进行两次单点修改：`D[l]` 加上 `k`，`D[r+1]` 减去 `k`。

**结合的挑战**：
我们可以用一个树状数组来维护差分数组 `D`，这样区间更新就变成了两次 O(log N) 的单点更新，非常快。但问题是，如何通过差分数组 `D` 快速计算出原数组 `A` 的区间和呢？

我们来推导一下原数组 `A` 的前缀和 `Sum_A(x)` 与差分数组 `D` 的关系。

首先，原数组的任意一项 `A[i]` 等于其差分数组的前缀和：
$$
A[i] = \sum_{j=1}^{i} D[j]
$$

那么，原数组的前缀和 `Sum_A(x)` 就是对 `A[i]` 的再次求和：
$$
Sum_A(x) = \sum_{i=1}^{x} A[i] = \sum_{i=1}^{x} \sum_{j=1}^{i} D[j]
$$

这个双重求和不方便直接计算。我们变换一下求和顺序，考虑每个 `D[j]` 对 `Sum_A(x)` 的贡献。`D[j]` 在 `A[j]`, `A[j+1]`, ..., `A[x]` 中都出现过，共出现了 `x - j + 1` 次。因此：
$$
Sum_A(x) = \sum_{j=1}^{x} (x - j + 1) \cdot D[j]
$$
将括号展开，得到：
$$
Sum_A(x) = (x+1) \sum_{j=1}^{x} D[j] - \sum_{j=1}^{x} j \cdot D[j]
$$

**最终结论**：为了快速求出 `Sum_A(x)`，我们需要维护两个量的前缀和：
1.  `∑ D[j]`
2.  `∑ j * D[j]`

这正是双树状数组的用武之地！
*   `t1`：第一个树状数组，用来维护 `D[j]` 的值。
*   `t2`：第二个树状数组，用来维护 `j * D[j]` 的值。

*(注：代码中为了实现上的便利，`t2` 维护的是 `(i-1)*D[i]`，公式略有变形，但原理完全相同。下文将以代码的实现为准进行分析。)*

---

## 代码逐行分析

### 1. 基础树状数组操作 (`lowbit`, `update`, `sum`)

这三个是标准的树状数组模板函数。

```cpp
// 低位运算：获取 n 在二进制下最低位的 1 所代表的值
int lowbit(int n) {
    return n & -n;
}

// 单点更新：在树状数组 t 上 idx 位置增加 val
void update(vector<long long> &t, int idx, long long val) {
    for (int i = idx; i < (int)t.size(); i += lowbit(i)) {
        t[i] += val;
    }
}

// 前缀和：查询树状数组 t 的 [1, idx] 和
long long sum(const vector<long long> &t, int idx) {
    long long res = 0;
    for (int i = idx; i > 0; i -= lowbit(i)) {
        res += t[i];
    }
    return res;
}
```

### 2. 区间加 (`range_add`)

这是核心的更新函数，它将一次区间更新分解为对两个树状数组的四次单点更新。

```cpp
void range_add(vector<long long> &t1, vector<long long> &t2, int l, int r, long long k) {
    // t1 维护差分 d[i]
    // t2 维护带权差分 (i-1)*d[i]

    // 步骤1: 更新 t1，对应 d[l] += k 和 d[r+1] -= k
    update(t1, l, k);
    update(t1, r + 1, -k);

    // 步骤2: 更新 t2，同步更新带权差分
    // d[l] 的变化导致 (l-1)*d[l] 增加了 k*(l-1)
    update(t2, l, k * (l - 1));
    // d[r+1] 的变化导致 r*d[r+1] 减少了 k*r
    update(t2, r + 1, -k * r);
}
```

### 3. 原数组前缀和 (`prefix_sum`)

此函数根据我们推导的公式，利用两个树状数组的结果来计算原数组的前缀和。

```cpp
long long prefix_sum(const vector<long long> &t1, const vector<long long> &t2, int x) {
    // 根据代码实现，公式为：Sum_A(x) = x * ∑D[i] - ∑(i-1)*D[i]
    return sum(t1, x) * x - sum(t2, x);
}
```
*   `sum(t1, x)` 得到 `∑(i=1 to x) D[i]`。
*   `sum(t2, x)` 得到 `∑(i=1 to x) (i-1)*D[i]`。
*   整个函数在 O(log N) 时间内计算出原数组 `A` 在 `[1, x]` 上的和。

### 4. 区间和查询 (`range_sum`)

这是一个经典技巧，利用前缀和相减得到区间和。

```cpp
long long range_sum(const vector<long long> &t1, const vector<long long> &t2, int l, int r) {
    // [l, r] 的和 = [1, r] 的和 - [1, l-1] 的和
    return prefix_sum(t1, t2, r) - prefix_sum(t1, t2, l - 1);
}
```

---

## 图表辅助理解

假设 `n=5`，原数组 `A` 初始全为 0。我们执行操作：**对区间 `[2, 4]` 加上 3**。

**1. 初始状态**

| 索引 `i`     |  1   |  2   |  3   |  4   |  5   |
| :----------- | :--: | :--: | :--: | :--: | :--: |
| `A[i]`       |  0   |  0   |  0   |  0   |  0   |
| `D[i]`       |  0   |  0   |  0   |  0   |  0   |
| `(i-1)*D[i]` |  0   |  0   |  0   |  0   |  0   |

**2. 操作: `range_add(t1, t2, 2, 4, 3)`**

这会分解为 4 个 `update` 调用：
1.  `update(t1, 2, 3)`
2.  `update(t1, 5, -3)`
3.  `update(t2, 2, 3 * (2-1)) = update(t2, 2, 3)`
4.  `update(t2, 5, -3 * 4) = update(t2, 5, -12)`

**3. 操作后状态**

此时，差分数组 `D` 和带权差分 `(i-1)D[i]` 在逻辑上变为：

| 索引 `i`         |  1   |  2   |  3   |  4   |  5   |
| :--------------- | :--: | :--: | :--: | :--: | :--: |
| **`D[i]`**       |  0   |  3   |  0   |  0   |  -3  |
| **`(i-1)*D[i]`** |  0   |  3   |  0   |  0   | -12  |

我们可以根据 `D` 数组还原出 `A` 数组的当前状态：
*   `A[1] = 0`
*   `A[2] = A[1] + D[2] = 0 + 3 = 3`
*   `A[3] = A[2] + D[3] = 3 + 0 = 3`
*   `A[4] = A[3] + D[4] = 3 + 0 = 3`
*   `A[5] = A[4] + D[5] = 3 - 3 = 0`

所以 `A` 数组现在是 `[0, 3, 3, 3, 0]`，操作正确。

**4. 查询: `range_sum(t1, t2, 3, 4)`**

这个查询会被分解为 `prefix_sum(4) - prefix_sum(2)`。

*   **计算 `prefix_sum(4)`**:
    *   `sum(t1, 4)` = `D[1]+...+D[4]` = `0+3+0+0` = `3`
    *   `sum(t2, 4)` = `0*D[1]+...+3*D[4]` = `0+3+0+0` = `3`
    *   `prefix_sum(4)` = `sum(t1, 4) * 4 - sum(t2, 4)` = `3 * 4 - 3` = `9`
    *   (验证: `A[1]+...+A[4] = 0+3+3+3 = 9`，正确)

*   **计算 `prefix_sum(2)`**:
    *   `sum(t1, 2)` = `D[1]+D[2]` = `0+3` = `3`
    *   `sum(t2, 2)` = `0*D[1]+1*D[2]` = `0+3` = `3`
    *   `prefix_sum(2)` = `sum(t1, 2) * 2 - sum(t2, 2)` = `3 * 2 - 3` = `3`
    *   (验证: `A[1]+A[2] = 0+3 = 3`，正确)

*   **最终结果**:
    *   `range_sum(3, 4)` = `prefix_sum(4) - prefix_sum(2)` = `9 - 3` = `6`
    *   (验证: `A[3]+A[4] = 3+3 = 6`，完全正确)

---

## 总结

该 C++ 代码是一个功能强大且高效的模板。它巧妙地将**差分思想**与**两个树状数组**结合，将复杂的区间更新和区间查询问题，转化为几次基础的、复杂度为 O(log N) 的单点更新和前缀和查询，是算法竞赛中解决此类问题的标准方案之一。





### 问题一：为什么 `t2` 维护的是 `(i-1)*D[i]` 而不是 `i*D[i]`？

这是一个非常棒的观察！答案是：**两者都可以，选择哪个只是一个代数变换的问题，最终都会得到正确的答案。** `(i-1)*D[i]` 的形式在某些推导和实现中可能显得更“整洁”一些。

我们来回顾一下核心推导公式：
$$
Sum_A(x) = \sum_{j=1}^{x} (x - j + 1) \cdot D[j]
$$
这个公式是所有推导的起点，是绝对正确的。现在我们有两个选择来拆分它：

---

#### 选择 1：维护 `i*D[i]` (你提到的方式)

我们可以把公式拆分为：
$$
Sum_A(x) = (x+1) \sum_{j=1}^{x} D[j] - \sum_{j=1}^{x} j \cdot D[j]
$$
如果选择这个方案：

* `t1` 维护 `D[i]`。

* `t2` 维护 `i * D[i]`。

* 那么求前缀和的函数 `prefix_sum(x)` 就要写成：

  ```cpp
  // 方案一的实现
  return sum(t1, x) * (x + 1) - sum(t2, x);
  ```

* 对应的，`range_add` 函数在更新 `t2` 时也要改变：

  *   `d[l]` 增加了 `k` => `l*d[l]` 增加了 `l*k`
  *   `d[r+1]` 减少了 `k` => `(r+1)*d[r+1]` 减少了 `(r+1)*k`

  ```cpp
  // 方案一的 range_add
  update(t2, l, k * l);
  update(t2, r + 1, -k * (r + 1));
  ```

  这个方案是完全正确的，并且也能通过所有测试。

---

#### 选择 2：维护 `(i-1)*D[i]` (代码中使用的方式)

我们也可以把公式拆分为另一种形式：
$$
\begin{aligned}
Sum_A(x) &= \sum_{j=1}^{x} (x - (j-1)) \cdot D[j] \\
&= x \sum_{j=1}^{x} D[j] - \sum_{j=1}^{x} (j-1) \cdot D[j]
\end{aligned}
$$
如果选择这个方案：

* `t1` 维护 `D[i]`。

* `t2` 维护 `(i-1) * D[i]`。

* 那么求前缀和的函数 `prefix_sum(x)` 就要写成：

  ```cpp
  // 方案二的实现 (代码中的实现)
  return sum(t1, x) * x - sum(t2, x);
  ```

* 对应的，`range_add` 函数也要做相应改变：

  *   `d[l]` 增加了 `k` => `(l-1)*d[l]` 增加了 `(l-1)*k`
  *   `d[r+1]` 减少了 `k` => `r*d[r+1]` 减少了 `r*k`

  ```cpp
  // 方案二的 range_add (代码中的实现)
  update(t2, l, k * (l - 1));
  update(t2, r + 1, -k * r);
  ```

  这个方案也是完全正确的。

**结论**：
选择维护 `i*D[i]` 还是 `(i-1)*D[i]` 只是个人偏好或模板习惯。两者在数学上是等价的，只是导致 `prefix_sum` 和 `range_add` 函数中的系数（是 `x` 还是 `x+1`，是 `l` 还是 `l-1`）略有不同。代码作者选择了第二种方案，它的系数看起来可能更简洁一些。

---

### 问题二：为什么我们不能在求和时直接用 `j*d[j]`，而是要维护一个新数组？

这是一个关于**数据结构核心价值**的深刻问题。答案是：**为了速度！**

树状数组的核心能力是**快速计算前缀和**。它只能对**预先存储好**的数据进行求和。

我们需要的 `∑ j * D[j]` 是一个全新的数列 `B[j] = j * D[j]` 的前缀和。我们无法凭空、实时地从只存储了 `D[j]` 的树状数组 `t1` 中，计算出 `B[j]` 的前缀和。

让我们来模拟一下，如果我们只有一个维护 `D[j]` 的树状数组 `t1`，想计算 `∑(j=1 to x) j * D[j]` 会发生什么：

1. 我们想知道 `1*D[1] + 2*D[2] + ... + x*D[x]` 的值。

2. 我们无法通过 `sum(t1, ...)` 的任何组合直接得到这个结果。`sum(t1, k)` 只能给我们 `D[1]+...+D[k]`。

3. 唯一的办法是，一个一个地把 `D[j]` 的值取出来，然后乘以 `j` 再相加。

   * 如何得到单个 `D[j]` 的值？用 `sum(t1, j) - sum(t1, j-1)`。这需要两次 O(log N) 的操作。

   * 为了计算 `∑(j=1 to x) j * D[j]`，我们需要循环 `x` 次：

     ```cpp
     // 这是一个非常慢的模拟过程
     long long total = 0;
     for (int j = 1; j <= x; ++j) {
         long long d_j = sum(t1, j) - sum(t1, j-1); // O(log N)
         total += j * d_j;
     }
     // 总时间复杂度为 O(x * log N)
     ```

这个 `O(x * log N)` 的时间复杂度太高了！在最坏情况下（`x` 接近 `N`），它会退化成 `O(N * log N)`，这使得整个算法的优势荡然无存。

**正确的做法（代码中的做法）：**

我们认识到 `∑ j * D[j]` 本质上是另一个数列的前缀和。所以，我们干脆**再创建一个树状数组 `t2`，专门用来维护 `j * D[j]` 这个数列**（或者是 `(j-1)*D[j]`）。

*   当 `D[j]` 发生变化时，我们不仅更新 `t1`，**同时**也计算出 `j*D[j]` 的变化量，并更新 `t2`。
*   这样，`t2` 中始终保存着 `j*D[j]` 的最新信息。
*   当我们需要 `∑(j=1 to x) j * D[j]` 时，我们直接调用 `sum(t2, x)`，这只需要 O(log N) 的时间！

**总结**：
我们用**空间换时间**。通过多使用一个树状数组 `t2` 的空间，我们将一个原本需要 `O(N * log N)` 时间才能完成的计算，加速到了 `O(log N)`。这正是双树状数组算法能够实现高效区间更新和查询的根本原因。

---

### 问题三：为什么 `t2` 是增加和减少那么多

记住我们的目标：`t2` 这个树状数组需要维护 `(i-1) * D[i]` 这个数列的值。当 `D[i]` 改变时，`t2` 必须跟着改变，以保证其数据的正确性。

我们的操作是：让原数组 `A` 的 `[l, r]` 区间所有数都加上 `k`。
这个操作会引发差分数组 `D` 在**两个点**上的变化：
1.  `D[l]` 的值增加了 `k`。
2.  `D[r+1]` 的值减少了 `k`。

现在，我们需要分析这两个变化分别对 `t2` 维护的 `(i-1) * D[i]` 数列造成了什么影响。

---

### 第一个变化：分析 `l` 位置

*   **差分数组的变化**：在 `l` 这个位置，`D[l]` 的值从原来的 `D_old[l]` 变成了 `D_old[l] + k`。
*   **我们要维护的数列的变化**：我们关心的是 `(i-1) * D[i]` 这个数列在 `i = l` 时的值变化了多少。
    *   变化前的值是：`(l - 1) * D_old[l]`
    *   变化后的值是：`(l - 1) * (D_old[l] + k)`
*   **计算变化量**：
    变化量 = (变化后的值) - (变化前的值)
    变化量 = `(l - 1) * (D_old[l] + k) - (l - 1) * D_old[l]`
    展开括号：
    变化量 = `(l - 1) * D_old[l] + (l - 1) * k - (l - 1) * D_old[l]`
    前后两项抵消，剩下：
    **变化量 = `(l - 1) * k`**

**结论**：因为 `D[l]` 增加了 `k`，导致 `(i-1) * D[i]` 这个数列在第 `l` 项上**增加**了 `(l - 1) * k`。
所以，我们需要在 `t2` 的第 `l` 个位置上增加 `(l-1) * k`。这正是这行代码的由来：
```cpp
update(t2, l, k * (l - 1));
```

---

### 第二个变化：分析 `r+1` 位置

*   **差分数组的变化**：在 `r+1` 这个位置，`D[r+1]` 的值从原来的 `D_old[r+1]` 变成了 `D_old[r+1] - k`。
*   **我们要维护的数列的变化**：我们关心的是 `(i-1) * D[i]` 这个数列在 `i = r+1` 时的值变化了多少。
    *   变化前的值是：`((r+1) - 1) * D_old[r+1]`  也就是 `r * D_old[r+1]`
    *   变化后的值是：`((r+1) - 1) * (D_old[r+1] - k)` 也就是 `r * (D_old[r+1] - k)`
*   **计算变化量**：
    变化量 = (变化后的值) - (变化前的值)
    变化量 = `r * (D_old[r+1] - k) - r * D_old[r+1]`
    展开括号：
    变化量 = `r * D_old[r+1] - r * k - r * D_old[r+1]`
    前后两项抵消，剩下：
    **变化量 = `-r * k`**

**结论**：因为 `D[r+1]` 减少了 `k`，导致 `(i-1) * D[i]` 这个数列在第 `r+1` 项上**减少**了 `r * k`。
所以，我们需要在 `t2` 的第 `r+1` 个位置上增加 `-r * k` (也就是减去 `r*k`)。这正是这行代码的由来：
```cpp
update(t2, r + 1, -k * r);
```

### 总结

简单来说，`update` 函数是用来更新一个数列的值的。
*   当我们更新 `t1` 时，我们是在更新 `D[i]` 这个数列。
*   当我们更新 `t2` 时，我们是在更新 `(i-1)*D[i]` 这个数列。

`D[l]` 变化了 `+k`，`D[r+1]` 变化了 `-k`。这是一个**直接**的变化。
而 `(i-1)*D[i]` 的变化是**间接**的，它依赖于 `D[i]` 的变化，并且前面还乘了一个系数 `(i-1)`。所以它的变化量不是简单的 `+k` 或 `-k`，而是要带上这个系数，变成了 `+k*(l-1)` 和 `-k*r`。