# 洛谷 P2161 [SHOI2009]会场预约 解题思路

## 问题简述

本题要求维护一个不重叠的区间集合。当用户尝试添加一个新区间 `[st, ed]` 时，我们需要：

1. 找出所有与 `[st, ed]` 重叠的已有区间。
2. 将这些重叠的区间从集合中删除。
3. 将新区间 `[st, ed]` 加入集合。
4. 报告本次操作删除了多少个旧区间。
   此外，还需要支持查询当前集合中总共有多少个区间。

**重叠条件**：两个区间 `[st1, ed1]` 和 `[st2, ed2]` 重叠，当且仅当 `st1 <= ed2` 且 `st2 <= ed1`。

## 核心挑战

如果每次添加新区间时，都遍历一遍当前所有的已有区间来检查是否重叠，当区间数量巨大时，这个过程会非常耗时，导致超时。因此，必须采用更高效的数据结构和算法。

## 解决方案：树状数组 + 二分查找

本解法利用树状数组（BIT）的快速前缀和查询能力，结合二分查找，来高效地定位并删除重叠区间。

### 1. 数据结构与实现

* **树状数组 `v`**:
    * **作用**: 维护一个关于**区间起点的计数器**。`update(st, 1)` 表示在 `st` 这个时间点增加了一个起点，`sum(k)`
      能快速查询出所有起点 `st_old <= k` 的区间总数。
* **辅助数组 `t`**:
    * **作用**: 记录每个起点对应的终点。`t[st] = ed` 存储了起点为 `st` 的区间的终点是 `ed`。

以下是树状数组的核心实现代码：

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<long long> v; // 树状数组，维护区间起点的数量

// 树状数组内部函数，用于计算最低位的1
int lowbit(int x) {
    return x & -x;
}

// 更新操作：在idx位置增加x
void update(int idx, int x) {
    for (int i = idx; i < v.size(); i += lowbit(i)) {
        v[i] += x;
    }
}

// 查询操作：计算从1到idx的前缀和
long long sum(int idx) {
    long long ans = 0;
    for (int i = idx; i > 0; i -= lowbit(i)) {
        ans += v[i];
    }
    return ans;
}
```

### 2. 算法流程

#### A. 添加新区间 `[st, ed]`

这是算法的核心。我们的目标是找到并删除所有满足 `st_old <= ed` 且 `st <= ed_old` 的旧区间 `[st_old, ed_old]`。代码通过一个
`while(true)` 循环来不断地寻找并删除重叠区间，直到找完为止。

```cpp
// ... 在 main 函数中 ...
if (temp == 'A') {
    int st, ed, ans1 = 0;
    cin >> st >> ed;
    
    while (true) {
        // 1. 筛选候选区间: 找出所有起点 st_old <= ed 的区间总数 k
        int k = sum(ed);
        if (k == 0) break; // 没有候选区间，不可能重叠，结束查找

        // 2. 精确定位: 在树状数组上二分查找，找到满足 st_old <= ed 的、起点最靠右的那个区间
        // 这个区间的起点是第 k 个起点
        int l = 1, r = ed, idx = 0;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (sum(mid) < k) {
                idx = mid;
                l = mid + 1;
            }
            else r = mid - 1;
        }
        int pos = idx + 1; // 这就是最可疑区间的起点 st_old

        // 3. 判断与删除: 检查第二个重叠条件 st <= ed_old
        if (t[pos] >= st) {
            // 条件满足，区间 [pos, t[pos]] 确实重叠
            update(pos, -1); // 从树状数组中移除该起点
            ans1++;          // 删除计数+1
            ans--;           // 总数-1
        }
        else {
            // 连起点最靠右的都不重叠，其他更左的也不可能重叠
            break;
        }
    }

    // 4. 加入新区间: 清理完毕后，加入新区间
    update(st, 1);
    t[st] = ed;
    ans++;
    cout << ans1 << endl;
}
```

#### B. 查询总数

这个操作非常简单。我们用一个变量 `ans` 实时维护着当前有效的区间总数。当收到查询指令时，直接输出 `ans` 即可。

```cpp
// ... 在 main 函数中 ...
else // temp == 'B'
    cout << ans << endl;
```

### 3. 复杂度分析

* 每次添加操作，`while` 循环最多执行 `d` 次，其中 `d` 是删除的区间数量。
* 循环内部，`sum` 操作和二分查找的复杂度都是 `O(logC)`，其中 `C` 是坐标的最大值。
* 因此，单次添加操作的总复杂度约为 `O(d * logC * logC)`。由于每个区间最多被删除一次，均摊下来效率非常高，足以通过本题。

### 4. 完整代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<long long> v; //维护st

int lowbit(int x) {
    return x & -x;
}

void update(int idx, int x) {
    for (int i = idx; i < v.size(); i += lowbit(i)) {
        v[i] += x;
    }
}

long long sum(int idx) {
    long long ans = 0;
    for (int i = idx; i > 0; i -= lowbit(i)) {
        ans += v[i];
    }
    return ans;
}

int main() {
    int n, ans = 0;
    cin >> n;
    vector<long long> t(2e5 + 10); //维护ed
    v.resize(2e5 + 10);
    for (int i = 1; i <= n; i++) {
        char temp;
        cin >> temp;
        if (temp == 'A') {
            int st, ed, ans1 = 0;
            cin >> st >> ed;
            //从后往前搜，找到第一个符合(st >= ed_old)的日程，即第一个末尾时间不大于新日程开始时间的日程
            while (true) {
                // 利用树状数组，快速查出所有开始时间 st_old <= ed 的日程总数 k
                int k = sum(ed);
                if (k == 0) break;
                // 我们要找的重叠日程，它的开始时间 st_old 必须满足 <= ed。
                // 为了尽快判断，我们先找一个满足 st_old <= ed 的日程中，开始时间最晚（最大）的那一个。
                // 下面这个 while 循环是在用“二分查找”的方法，在树状数组上快速定位这个最晚的开始时间。
                // 你可以把它理解成一个黑盒：它能高效地找到第 k 个被标记的开始时间点在哪里。
                int l = 1, r = ed, idx = 0;
                while (l <= r) {
                    int mid = l + (r - l) / 2;
                    if (sum(mid) < k) {
                        idx = mid;
                        l = mid + 1;
                    }
                    else r = mid - 1;
                }
                int pos = idx + 1; // 要删除的位置，1-base
                // 我们已经满足了重叠的第一个条件 st_old <= ed (因为 pos <= ed)。
                // 现在检查第二个条件：st <= ed_old
                // t[pos] 就是这个日程的结束时间 ed_old
                if (t[pos] >= st) {
                    // 两个条件都满足！说明日程 [pos, t[pos]] 和新日程 [st, ed] 重叠了。
                    update(pos, -1);
                    ans1++; //删除数+1
                    ans--;  //总日程数-1
                }
                else {
                    // 如果连这个开始时间最晚的都不满足第二个条件，
                    // 那么其他开始时间更早的，也肯定不会满足。
                    // 所以可以直接确定，没有更多重叠的了。
                    break;
                }
            }
            update(st, 1); //将新日程加入至树状数组
            t[st] = ed;    //记录ed
            ans++;         //总日程数+1
            cout << ans1 << endl;
        }
        else
            cout << ans << endl;
    }
    return 0;
}
```